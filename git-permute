#!/usr/bin/env python3
from gitz.git import GIT
from gitz.git import combine
from gitz.git import functions
from gitz.git import root
from gitz.program import ARGS
from gitz.program import PROGRAM
from typing import Iterator

SUMMARY = 'Reorder and delete commits in the current branch'

DANGER = 'Rewrites history!'

HELP = """
Permutes the commits in the current branch, perhaps deleting some.

For example, ``git permute ba`` switches the first and second most
recent commits, ``git permute cba`` swaps the first and third
commits, ``git permute cab`` pops the third commit to be the most
recent, top commit on the branch.

"""

EXAMPLES = """
git permute 10
git permute ba
    Switches the first and second most recent commits

git permute ab
git permute abc
git permute 01
git permute 012
    Do nothing

git permute cab
git permute 201
    Cycles the three most recent commits so the third one is first

git permute edcg
git permute 5437
    Deletes the most recent two commeits, reverses the next three, and
    deletes the sixth.

git permute edcg -s 'My message'
git permute edcg --squash='My message'
git permute 5437 -s "My message"
    Same as the previous command, but squashes the three commits into
    one with the commit message 'My message'

NEW:

git permute a+b  Same as old style git permute ab -s, using commit message of b
git permute a-b Like git permute -s but uses commit message of a
git permute a+b-c  Uses commit message of b
git permute a-b+c. Uses commit message of a; or, illegal?

"""

def segments(s: str) -> Iterator[str]:
    stack = ""
    for i in s:
        if i not in "+-" and stack and stack[-1] not in "+-":
            yield stack
            stack = ""
        stack += i
    if stack:
        yield stack


def segment_to_commits(segment: str) -> str:
    "a+b-c+d"
    assert len(segment) % 2 == 1, segment
    segment += "-"
    name, sign = zip(*(segment[i:i + 2] for i in range(0, len(segment), 2)))
    return "".join(name), sign.index("-")


def segments_to_commits(s):
    for seg in segments(s):
        yield segment_to_commits(seg)


def git_permute():
    def report(name, items, symbol):
        if items:
            s = '' if len(items) == 1 else 's'
            PROGRAM.message(len(items), 'commit%s %s' % (s, name))
            for id, msg in items:
                PROGRAM.message('%s %s: %s' % (symbol, id, msg))
            return True

    root.check_clean_workspace()
    perm = combine.permutation(ARGS.permutation, ARGS.squash)

    if not perm:
        PROGRAM.message('No change')
        return

    count = max(perm) + 1
    id_msgs = functions.commit_messages(count)
    ids = [id for id, _ in id_msgs]

    base, *perm_ids = (ids[i] for i in reversed(perm))

    for i in range(count):
        if i not in perm:
            print('-', *id_msgs[i])

    GIT.reset('--hard', base)
    results = []
    for symbol, commit_id, msg in combine.combine(perm_ids, ARGS.squash):
        print(f'{symbol}{commit_id}', end=' ', flush=True)
        results.append((symbol, commit_id, msg))

    PROGRAM.message()
    for args in reversed(results):
        PROGRAM.message(*args)


def add_arguments(parser):
    add_arg = parser.add_argument
    add_arg('permutation', help=_HELP_PERMUTATION)
    combine.add_arguments(parser)


_HELP_PERMUTATION = 'Pattern string to permute'

if __name__ == '__main__':
    PROGRAM.start()
